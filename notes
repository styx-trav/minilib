maths ::
	julia fractal ::
		common functions : z4 = csin(z3), or cexp(z3), or c /? cos(z3) or cz3(1 - z3), (or z3^2 + c);
		goal :: for what z complex number do we tend to infinity, and how fast;
		calc :: every coord gets a z = x + iy complex, plugged into the chosen equation.
		disp :: different color based on the module(%2, i think ? maybe based on the c given) of the abs value for a given n;


ex :: int equ(z, c) { return (z * z + c)
for a given (x, y) in the plane ::
int	is_stable(z, end, c)
	while (n < end)
		if (abs(z) > 2)
			return (-1);
		z = equ(z, c);
		n++;
	return (n);

int	clr_scale(x, y, end, c)
	complex z = cmplx(x, y);
	scale = is_stable(z, end, c);

and then scale the color according to the precision given. also keep in mind the precision of x, y to add the correct amount of distance for a given (round) pixel position. (maybe take in as argument the size of the graph wanted ? and adjust on zoom if needed.)

graphs ::
	disp :: almost done, just needing the mathematical equations to choose the display (and the red cross for closing)
	
	memory :: still working (destroy img after new one is pushed, and then supposedly :: end loop, destroy current img, destroy window, destroy/free mlx)
	

notes :: cant seem to find whether or not im allowed the complex header and functions :: we ll rewrite the equ from scratch if necessary ; for now we use the :: double complex = CMPLX(real, img);;

testing in the real numbers only rn, and with no neg numbers (so backwards from the usual axes) :: calc functions done, now to combine with our mlx so I can act see it

beautiful !!! they're all so gorgeous, also made my own complex nums going strong now. Here a given of the architecture i'd like to see ::

argvs ::
	single characters : m for mandel, j for julia, others for other kinds of fractals of course;
	c : given as two argvs, real then img (unforgiving atoi, dot for float);
	looper : given as a y/n, will loop trough every value of c constantly
	end : one arg, full int, max number of iterations;

in my struct ::
	center : current center of the fractal (0, 0), changed by the clicking of the mouse to any part of the screen;
	pixel : current scale pixel/axis (0.005), multed or divvied by the zoom feature;
	vert : (800), adjusted with the resize-redirect window;
	hor : (800), //
	c : complex_c, either chosen or looping (-1, -1 -> 1, 1 :: 0.001) throughout;
	the usuals : mlx/win/current_img/next_img(?)
	cap : (2);
	end : (100) or chosen (will affect the speed of the image rendering, esp for big images, will also affect the precision work (more black));
	equation : the chosen fractal equation (m, j, others);

calculations ::
	x : center - hor / 2, then < center + hor / 2 + hor % 2;
	y : center - vert / 2, then < center + vert / 2 + vert % 2;
	z : {x * pixel, y * pixel};
	color : decide on the color scheme (green, red, blue), then * scale and % 255, get_color for each;

